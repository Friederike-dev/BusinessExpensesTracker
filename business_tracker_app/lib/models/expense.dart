/**
 * Expense Model - Data class representing a business expense
 * 
 * This model class mirrors the backend Expense entity and handles
 * JSON serialization/deserialization for API communication.
 * 
 * Features:
 * - Immutable data structure with const constructor
 * - Required and optional fields matching backend validation
 * - JSON conversion methods for API integration
 * - DateTime formatting for backend compatibility
 * - Copy method for state updates
 * 
 * @author Friederike H.
 * @version 1.0
 * @since 2025-01-30
 */
class Expense {
  // === PROPERTIES ===

  /// Unique identifier (auto-generated by backend)
  final int? id;

  /// Title/name of the expense (required)
  /// Must be 1-255 characters
  final String title;

  /// Monetary amount of the expense (required)
  /// Must be between 0.01 and 999999.99
  final double amount;

  /// Category classification (required)
  /// Examples: "Travel", "Office Supplies", "Meals"
  /// Maximum 100 characters
  final String category;

  /// Date and time when expense occurred (required)
  final DateTime expenseDate;

  /// Additional description or notes (optional)
  /// Maximum 1000 characters
  final String? description;

  /// Path to receipt image file (optional)
  /// Future feature for receipt management
  /// Maximum 500 characters
  final String? imagePath;

  /// Timestamp when record was created (set by backend)
  final DateTime? createdAt;

  /// Timestamp when record was last updated (set by backend)
  final DateTime? updatedAt;

  // === CONSTRUCTOR ===

  /**
   * Creates a new Expense instance
   * 
   * Required fields: title, amount, category, expenseDate
   * Optional fields: id, description, imagePath, createdAt, updatedAt
   */
  const Expense({
    this.id,
    required this.title,
    required this.amount,
    required this.category,
    required this.expenseDate,
    this.description,
    this.imagePath,
    this.createdAt,
    this.updatedAt,
  });

  // === HELPER METHODS ===

  /// Helper method: Format DateTime for backend compatibility
  /// Simplifies to Year-Month-Day + Hour (no minutes, seconds, milliseconds)
  /// Format: "2025-07-26T17:00:00"
  ///
  /// This ensures consistent date formatting across the application
  /// and prevents timezone/precision issues with the backend.
  static String _formatDateTimeForBackend(DateTime dateTime) {
    final year = dateTime.year.toString().padLeft(4, '0');
    final month = dateTime.month.toString().padLeft(2, '0');
    final day = dateTime.day.toString().padLeft(2, '0');
    final hour = dateTime.hour.toString().padLeft(2, '0');

    return '$year-$month-${day}T$hour:00:00';
  }

  /// Konvertiert Expense zu JSON (für API-Requests)
  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      'title': title,
      'amount': amount,
      'category': category,
      'expenseDate': _formatDateTimeForBackend(expenseDate),
      if (description != null) 'description': description,
      if (imagePath != null) 'imagePath': imagePath,
      if (createdAt != null) 'createdAt': _formatDateTimeForBackend(createdAt!),
      if (updatedAt != null) 'updatedAt': _formatDateTimeForBackend(updatedAt!),
    };
  }

  /// Factory constructor für JSON Deserialisierung (von API)
  factory Expense.fromJson(Map<String, dynamic> json) {
    return Expense(
      id: json['id'] as int?,
      title: json['title'] as String,
      amount: (json['amount'] as num).toDouble(),
      category: json['category'] as String,
      expenseDate: DateTime.parse(json['expenseDate'] as String),
      description: json['description'] as String?,
      imagePath: json['imagePath'] as String?,
      createdAt: json['createdAt'] != null
          ? DateTime.parse(json['createdAt'] as String)
          : null,
      updatedAt: json['updatedAt'] != null
          ? DateTime.parse(json['updatedAt'] as String)
          : null,
    );
  }

  /// Copy-Methode für Updates
  Expense copyWith({
    int? id,
    String? title,
    double? amount,
    String? category,
    DateTime? expenseDate,
    String? description,
    String? imagePath,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return Expense(
      id: id ?? this.id,
      title: title ?? this.title,
      amount: amount ?? this.amount,
      category: category ?? this.category,
      expenseDate: expenseDate ?? this.expenseDate,
      description: description ?? this.description,
      imagePath: imagePath ?? this.imagePath,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// String-Repräsentation für Debugging
  @override
  String toString() {
    return 'Expense(id: $id, title: $title, amount: $amount, category: $category)';
  }

  /// Equality-Check für Tests und UI-Updates
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Expense &&
        other.id == id &&
        other.title == title &&
        other.amount == amount &&
        other.category == category &&
        other.expenseDate == expenseDate;
  }

  @override
  int get hashCode {
    return id.hashCode ^
        title.hashCode ^
        amount.hashCode ^
        category.hashCode ^
        expenseDate.hashCode;
  }
}
